{"version":3,"sources":["graphSVG.tsx","DCEL.tsx","PointInPolygon.tsx","App.tsx","Algorithms.tsx","Utils.tsx","reportWebVitals.ts","index.tsx"],"names":["GraphSVG","graphData","polylinesPoints","polygons","polygon","polygonString","edgeIndex","startVertexIndex","edges","x","vertices","y","push","join","minX","Infinity","maxX","minY","maxY","vertexIndex","v","pointSets","this","jsontoPolygon","i","length","uniqueKey","toString","randomColor","Math","random","id","className","fill","points","viewBoxInputs","scaleViewBox","props","data","viewBox","createPolygons","React","Vertex","name","edgeStar","sort","a","b","angleOffAxis","currentEdge","twinEdge","twin","nextIndex","indexOf","DirectedEdge","v1","v2","startVertex","endVertex","edge","getVector","vecX","vecY","atan2","Ax","Ay","Polygon","total","e","DCEL","edge1","edge2","inputVertices","inputEdges","vertex","v1Index","v2Index","addEdgeTwins","orderEdgeStar","visitedEdges","Set","has","add","origin","nextEdge","getNextEdgeFromStar","pathIsClockwise","inputPolygons","p","eIndex","vertexForJson","edgeForJson","startVIndex","endVIndex","polygonForJson","polygonEdges","allNeighbors","undefined","neighbor","originPolygon","neighborLayer","visitedPolygons","visitQueue","layerCount","layerLength","currentPolygon","splice","neighbors","findPolygonNeighbors","neighborPolygon","pathOrientation","p1","p2","p3","val","onColinearSegment","P","Q","R","inMaxX","max","inMinX","min","inMaxY","inMinY","pointInPolygon","point","wind","delta","windingNumber","App","useState","testCase","setTestCase","testCaseIndex","dataGraph","testData","description","neighborOrigin","output1","inputData","console","log","myDCEL","input","fromVerticesEdges","jsonGraph","toJSON","algorithm1","output2","inFromA1","originPolygonIndex","fromVerticesEdgesPolygons","index","polygonNeighborNames","map","algorithm2","output3","pointCoordinates","containerPolygon","algorithm3","output4","polygonNeighborLayers","findPolygonNeighborLayers","JSON","stringify","algorithm4","descriptionText","concat","text1","text2","text3","text4","onChange","handleOnChange","target","value","options","title","dropdownOptions","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ad70433b.chunk.js","sourcesContent":["import * as React from 'react';\nimport {jsonGraph} from \"./Utils\"\n\n/**\n * Graph SVG input\n */\ninterface IProps {\n    data: jsonGraph;\n  }\n  \n/**\n * Returns an SVG with drawn polygon element.\n * \n * Formats polygon points from the jsonGraph format. Creates SVG element. Populates SVG with polygons. Scales SVG with\n * a viewbox.  \n */\nexport class GraphSVG extends React.Component<IProps> {\n    /**\n     * Returns formatted polygon points from the jsonGraph format\n     * @param graphData \n     * @returns array of formatted strings for the polygon points\n     */\n    jsontoPolygon(graphData: jsonGraph): string[]{\n      let polylinesPoints: string[] = [];\n      \n      for(let polygon of graphData.polygons){\n        const polygonString: string[] =[];\n\n        for(let edgeIndex of polygon){\n          const startVertexIndex = graphData.edges[edgeIndex][0];\n          const x = graphData.vertices[startVertexIndex][0];\n          const y = graphData.vertices[startVertexIndex][1];\n          polygonString.push((x + \",\" + y)); \n        }\n        polylinesPoints.push(polygonString.join(\" \"));\n        }\n      return polylinesPoints;\n    }\n    \n    /**\n     * Returns viewbox parameters to scale SVG to fit the polygon drawing\n     * \n     * @param graphData \n     * @returns SVG viewbox parameters [minX, minY, width, height]\n     */\n    scaleViewBox(graphData: jsonGraph){\n        let minX = Infinity;\n        let maxX = -Infinity;\n        let minY = Infinity;\n        let maxY = -Infinity;\n        //loops through polygons, to edges, to vertices so we can scale the viewbox to only points in the polygons\n        for(let polygon of graphData.polygons){\n            for(let edgeIndex of polygon){\n                const edge = graphData.edges[edgeIndex];\n                const vertexIndex = edge[0];\n                const v = graphData.vertices[vertexIndex];\n                \n                if(v[0]< minX){\n                    minX = v[0];\n                }\n                if(v[0]> maxX){\n                    maxX = v[0];\n                }\n                if(v[1]< minY){\n                    minY = v[1];\n                }\n                if(v[1]>maxY){\n                    maxY = v[1];\n                }\n            }\n        }      \n      return([minX, minY, (maxX-minX), (maxY-minY)]);\n    }\n  \n    /**\n     * Returns the all polygons drawn as html SVG elements\n     * \n     * Gives each polygon a unique id that refers to its index in the DCEL structure. Fills it with a random color.\n     * \n     * @param graphData \n     * @returns polygons as SVG elements \n     */\n    createPolygons(graphData: jsonGraph) {\n      const pointSets: string[] = this.jsontoPolygon(graphData);\n      \n      let polygons = [];\n      for(let i=0; i<pointSets.length; i++){\n        const uniqueKey = \"polygon\" + i.toString();\n        const randomColor = \"#\" + ((1<<24)*Math.random() | 0).toString(16);\n        const id = \"P\" + i.toString();\n        polygons.push(\n            <polygon \n                className = \"Polygons\"\n                id = {id}\n                key = {uniqueKey}\n                fill={randomColor}\n                points={pointSets[i]}> \n                <title>{id}</title>\n            </polygon>)\n      }\n      return polygons\n    }\n  \n    render() {\n      const viewBoxInputs =this.scaleViewBox(this.props.data);\n\n      return (\n        <div className = \"Graph-drawing\">\n          <svg className= \"SVG\" viewBox={`${viewBoxInputs[0]} ${viewBoxInputs[1]} ${viewBoxInputs[2]} ${viewBoxInputs[3]}`}>\n            {this.createPolygons(this.props.data)}\n          </svg>\n        </div>\n      );\n    }\n  }","import {jsonGraph} from \"./Utils\"\n\n//general functions\n/** brief, one line description\n * \n * Describe what this is doing, also because it has a complex return type,\n * describe the return type here, too\n * \n * linear in the number of edges of a polygon, O(n) where n is number of edges in polygon\n */\n\n/**\n * Returns the angle between the directed edge and horizontal axis running through the edge start point\n * The angle output runs from -pi rad (-180 deg) to pi rad (180 deg) where 0 rad (0 deg) is the positive x axis\n * \n * @param edge \n * @returns number representing angle in radians off horizontal axis \n */\nfunction angleOffAxis(edge: DirectedEdge): number{\n  const [vecX, vecY] = edge.getVector();\n  const angle = Math.atan2(vecY, vecX);\n  return angle;\n}\n\n/**\n * Vertex class represents the 2d points in the DCEL graph\n * \n * edgeStar: consists of the edges in the graph that start at the given vertex, directed outward\n */\nclass Vertex {\n  name: string = \"\";\n  x: number;\n  y: number;\n  edgeStar: DirectedEdge[] = []; \n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Orders edges in edge star by the edge's angle off axis property\n   * \n   * The edges will be ordered starting counter-clockwise from the -x axis through the vertex as a result of the output\n   * of the angleOffAxis function. Ordering the edges simplifies the process for finding neighboring edges while \n   * traversing polygon cycles to create the DCEL\n   * \n   */\n  orderEdgeStar() {\n    //order edges from -x axis CCW\n    this.edgeStar.sort((a,b) => a.angleOffAxis - b.angleOffAxis);\n  }\n\n  /**\n   * Returns the next directed edge in the edge star\n   * \n   * First we find the given edge's twin because the given edge does not originate at the vertex we are trying to \n   * traverse and therefore will not be in the edge star. We find the edge twin through the directed edge properties. \n   * Then search for the edge twin in the edge star. Selecting the next edge from the twin in the edge star ensures you \n   * took the smallest right turn at the vertex while traversing from the input edge. \n   * \n   * See DirectedEdge class for edge twin description. See Vertex Class properties for edge star description. \n   * \n   * @param currentEdge a Directed edge where the endVertex is where we are turning from while traversing the polygon cycle\n   * @returns nextEdge as a DirectedEdge\n   */\n  getNextEdgeFromStar(currentEdge: DirectedEdge):DirectedEdge{\n    const twinEdge = currentEdge.twin;\n    const currentIndex = this.edgeStar.indexOf(twinEdge);\n    let nextIndex = currentIndex + 1;\n    //if you're at the end of the edgeStar[], go back to beginning\n    if (nextIndex >= this.edgeStar.length){\n      nextIndex = 0;\n    }\n    const nextEdge = this.edgeStar[nextIndex];\n    return nextEdge;\n  }\n}// closes Vertex class\n\n\n/**\n * Directed edge class represents an edge in the DCEL graph. \n * \n * The Directed edge is directed in that the startVertex and endVertex are not interchangable. The Directed edge in the \n * reverse direction is defined as it's twin. Therefore, an undirected edge is defined by a directed edge and it's twin \n * For that reason, directed edges are also known as half-edges. Each directed edge can only be associated with one \n * polygon.\n * \n * twin: the directed edge's pair with opposite start and end verticies. This property is always set when adding edge \n * twins in a DCEL graph. It is set after each directed edge is constructed. \n * angleOffAxis: the angle between the directed edge and the positive horizontal axis through the start point. \n * polygon: the polygon that the edge is associated with. Each edge can only be associated with one polygon in a DCEL\n */\nexport class DirectedEdge {\n  name: string = \"\";\n  startVertex: Vertex;\n  endVertex: Vertex;\n  twin!: DirectedEdge; \n  angleOffAxis: number;\n  polygon!: Polygon;\n\n  constructor(v1: Vertex, v2: Vertex){\n    this.startVertex = v1;\n    this.endVertex = v2;\n    this.angleOffAxis = angleOffAxis(this); \n  }\n\n  /**\n   * Returns a 2d vector as [x,y] from the DirectedEdge startVertex to the endVertex\n   * \n   * @param this DirectedEdge\n   * @returns 2d vector as [x,y]\n   */ \n  getVector(this: DirectedEdge):[number, number]{\n    const Ax: number = this.startVertex.x;\n    const Ay: number = this.startVertex.y;\n    const Bx: number = this.endVertex.x;\n    const By: number = this.endVertex.y;\n    return [(Bx-Ax), (By-Ay)];\n  }\n} //closes DirectedEdge class\n\n/**\n * Polygon class represents the polygons of a DCEL graph\n * \n * Polygons are defined by a list of their directed edges. The directed edges are ordered by the way they are traversed \n * around the polygon. The start/end edge is not integral to the definition- they can be shifted as long as the overall\n * order remains the same.\n */\nexport class Polygon{\n  name: string = \"\";\n  edges: DirectedEdge[] = [];\n\n  /**\n   * Checks if path of closed polygon is clockwise or counter-clockwise\n   * @returns true for CW path, false for CCW path\n   */\n  pathIsClockwise(): boolean{\n    let total = 0;\n    for(let e of this.edges){\n      const v1 = e.startVertex;\n      const v2 = e.endVertex;\n      const edgeVal = (v2.x - v1.x)*(v2.y + v1.y);\n      total += edgeVal;\n    }\n    //>0 is clockwise\n    if(total > 0){\n      return true;\n    }\n    //<0 is counterclockwise\n    else{\n      return false;\n    }\n  }\n}// closes Polygon class\n\n\n/**\n * DCEL class represents the DCEL structure\n * \n * DCEL: doubly connected edge list data structure. (also known as a half-edge data structure) The class represents the \n * list of verticies, directed edges, and polygons the data structure is made of. \n */\nexport class DCEL{\n  vertices: Vertex[] = [];\n  edges: DirectedEdge[] = [];\n  polygons: Polygon[] = [];\n\n  /**\n   * Adds an edge and its twin to a DCEL\n   * \n   * This function created and edge and its twin as directed edges. Once created it sets each directed edge's twin as \n   * each other. It names the directed edges based on the number of edges in the graph. It adds each directed edge to \n   * the DCEL. Lastly, it adds each directed edge to their respective start vertex edge stars.\n   * \n   * O(1) constant time for each pair of vertices supplied\n   * \n   * @param v1 Vertex 1\n   * @param v2 Vertex 2\n   */\n  addEdgeTwins(v1: Vertex, v2: Vertex){\n    //create directed edge and twin for each given edge \n    const edge1 = new DirectedEdge(v1, v2);\n    const edge2 = new DirectedEdge(v2, v1);\n\n    //set edge properties: name and twin\n    edge1.name = \"e\" + this.edges.length.toString();\n    edge2.name = \"e\" + (this.edges.length +1).toString();\n    edge1.twin = edge2;\n    edge2.twin = edge1;\n\n    //add edges to DCEL\n    this.edges.push(edge1);\n    this.edges.push(edge2);\n\n    //add edges to their respective vertex stars\n    v1.edgeStar.push(edge1);\n    v2.edgeStar.push(edge2);\n  }\n\n  /**\n   * Creates a DCEL graph from given verticies and edges\n   * \n   * First, the function creates a vertex from each x,y coordinate pair in inputVerticies and adds it to the graph. Next, \n   * it adds a directed edge and its twin for each edge in inputEdges to the graph using the addEdgeTwins function. Now \n   * that we have all of the verticies and edges, we order the edge stars for each vertex. The graph is now prepared to \n   * search for polygons. \n   * \n   * To find all of the polygons we will visit all of the directed edges in a DFS. We will traverse the potential polygon \n   * by choosing the smallest clockwise turn from each directed edge's end vertex. We do this by the vertex, \n   * getNextEdgeFromStar function. When we return to the start edge, we know we have found a polygon. If it traverses in \n   * a clockwise direction, we add the polygon to the graph and note the polygon for each DirectedEdge polygon property. \n   * Otherwise, it is the polygon that represents the outer polygon. We never visit any directed edge twice, therefore \n   * when we've visited all of the directed edges we have found all possible smallest polygons.   \n   * \n   * parameter format:\n   * inputVertices: [[x1,y1], [x2,y2], [x3,y3]...]\n   * inputEdges: [[startVertexIndex, endVertexIndex], [startVertexIndex, endVertexIndex]...]\n   * \n   * O(n) where n is the number of supplied edges\n   * \n   * @param inputVertices given as a list of x,y coordinates\n   * @param inputEdges  given as a list of index pairs into the inputVertices list\n   */\n  fromVerticesEdges(inputVertices: number[][], inputEdges: number[][]){\n    //add vertices to DCEL\n    for(let [x, y] of inputVertices){\n      const vertex = new Vertex(x,y);\n      vertex.name = \"v\" + this.vertices.length.toString();\n      this.vertices.push(vertex);\n    }\n\n    //add edges to DCEL\n    for(let [v1Index, v2Index] of inputEdges){\n      const v1 = this.vertices[v1Index];\n      const v2 = this.vertices[v2Index];\n      this.addEdgeTwins(v1, v2);\n    }\n\n    //order vertex edge stars\n    for(let v  of this.vertices){\n      v.orderEdgeStar();\n    }\n\n    //add polygon cycles to DCEL\n    let visitedEdges = new Set();\n\n    for(let edge of this.edges){\n      //if you've already been to this edge, move on\n      if(visitedEdges.has(edge)){\n        continue;\n      }\n      //else, start traversing the cycle to find polygon\n      let currentEdge = edge;\n      visitedEdges.add(currentEdge);\n      let origin = edge.startVertex;\n      let polygon = new Polygon();\n      polygon.edges.push(edge);\n\n      while(origin !== currentEdge.endVertex){\n        let endVertex = currentEdge.endVertex;\n        let nextEdge = endVertex.getNextEdgeFromStar(currentEdge);\n        \n        if(visitedEdges.has(nextEdge)){\n          break;\n        }\n        visitedEdges.add(nextEdge);\n        polygon.edges.push(nextEdge);\n        currentEdge = nextEdge;\n      }\n\n      //add polygon to DCEL if it is an inside polygon\n      if(polygon.pathIsClockwise()){\n        polygon.name = \"p\" + this.polygons.length.toString();\n        this.polygons.push(polygon);\n\n        for(let edge of polygon.edges){\n          edge.polygon = polygon;\n        }\n      }\n    }\n  } \n\n  /**\n   *  Creates a DCEL graph from given verticies and edges\n   * \n   * First, the function creates a vertex from each x,y coordinate pair in inputVerticies and adds it to the graph. Next, \n   * it adds a directed edge and its twin for each edge in inputEdges to the graph using the addEdgeTwins function. The \n   * input format includes both the directed edge and and its twin, so every second edge can be skipped while using \n   * addEdgeTwins. Now that we have all of the verticies and edges, we order the edge stars for each vertex. Lastly, we\n   * add each polygon by creating an array of Directed edges from the list of edge indexes. \n   * \n   * parameter format:\n   * inputVertices: [[x1,y1], [x2,y2], [x3,y3]...]\n   * inputEdges: [[startVertexIndex, endVertexIndex], [startVertexIndex, endVertexIndex]...]\n   * inputPolygons: [[edgeIndex1, edgeIndex2, edgeIndex3], [edgeIndex4, edgeIndex5, edgeIndex6]...]\n   * \n   * O(n) time where n is the number of directed edges\n   * \n   * @param inputVertices \n   * @param inputEdges \n   * @param inputPolygons \n   */\n  fromVerticesEdgesPolygons(inputVertices: number[][], inputEdges: number[][], inputPolygons: number[][]){\n    //add vertices to DCEL\n    for(let [x, y] of inputVertices){\n      const vertex = new Vertex(x,y);\n      vertex.name = \"v\" + this.vertices.length.toString();\n      this.vertices.push(vertex);\n    }\n\n    //add edges to DCEL\n    //every 2nd edge is a twin, so you can skip initiating adding the edge for every other edge\n    for(let i= 0; i< inputEdges.length; i+=2){\n      let [v1Index, v2Index] = inputEdges[i];\n\n      const v1 = this.vertices[v1Index];\n      const v2 = this.vertices[v2Index];\n      this.addEdgeTwins(v1, v2);\n    }\n\n    //order vertex edge stars\n    for(let v  of this.vertices){\n      v.orderEdgeStar();\n    }\n\n    //add polygons to DCEL\n    for(let p of inputPolygons){\n      let polygon = new Polygon();\n      for(let eIndex of p){\n        let edge = this.edges[eIndex];\n        polygon.edges.push(edge);\n      }\n      polygon.name = \"p\" + this.polygons.length.toString();\n      this.polygons.push(polygon);\n\n      for(let edge of polygon.edges){\n        edge.polygon = polygon;\n      }\n    }\n  }\n\n  /**\n   * Returns the DCEL graph in a JSON format\n   * \n   * Output format is defined by inteface jsonGraph\n   * Output format: {inputVertices: [[x1,y1], [x2,y2], [x3,y3]...]\n   *                 inputEdges: [[startVertexIndex, endVertexIndex], [startVertexIndex, endVertexIndex]...]\n   *                 inputPolygons: [[edgeIndex1, edgeIndex2, edgeIndex3], [edgeIndex4, edgeIndex5, edgeIndex6]...]\n   *                }\n   * \n   * @returns jsonGraph of DCEL data structure\n   */\n  toJSON():jsonGraph{\n    let vertexForJson = [];\n    for(let vertex of this.vertices){\n      let x = vertex.x;\n      let y = vertex.y;\n      //add vertex as [x, y]\n      vertexForJson.push([x,y]);\n    }\n\n    let edgeForJson = []\n    for(let edge of this.edges){\n      let startVIndex = this.vertices.indexOf(edge.startVertex);\n      let endVIndex = this.vertices.indexOf(edge.endVertex);\n      //add edge as [startVIndex, endVIndex]\n      edgeForJson.push([startVIndex, endVIndex]);\n    }\n\n    let polygonForJson = []\n    for(let polygon of this.polygons){\n      let polygonEdges = [];\n      for(let edge of polygon.edges){\n        let edgeIndex = this.edges.indexOf(edge);\n        polygonEdges.push(edgeIndex);\n      }\n      //add polygon as [edgeIndex1,2,3...]\n      polygonForJson.push(polygonEdges);\n    }\n\n    const json: jsonGraph = {vertices: vertexForJson, edges: edgeForJson, polygons: polygonForJson};\n    return(json);\n  }\n\n  /**\n   * Returns the neighbors of a polygon as an array of polygons\n   * \n   * This function starts at a polygon and looks through each edge to find neighboring polygons. The existing references \n   * with the DCEL data structure simplifies this process because edges know their twins and each of those twins will \n   * know if they are associated with a polygon. Therefore, we can start at a polygon, go to each edge (edge[i]), then \n   * to the twin of that edge (edge[i].twin), then to the associated polygon. If an associated polygon exists, we add it \n   * to our neighbors array.\n   * \n   * O(n) where n represents the number of edges in the polygon. \n   * \n   * @param polygon \n   * @returns polygon[] representing the neighboring polygons\n   */\n  findPolygonNeighbors(polygon: Polygon): Polygon[]{\n    let allNeighbors: Polygon[] = []\n    for(let edge of polygon.edges){\n      if(edge.twin.polygon !== undefined){\n        const neighbor = edge.twin.polygon;\n        allNeighbors.push(neighbor);\n      }\n    }\n    return allNeighbors;\n  }\n\n  /**\n   * Returns neighbor layers as an array with an array of polygon names for each layer\n   * \n   * This function performs a BFS to traverse the graph and find the neighbor layers from a given polygon. We start our \n   * queue with the origin polygon and continue as long as our queue has polygons to visit. We never visit a polygon \n   * twice. We keep track of which layer we are on with layerCount and the number of polygons of the queue we need to \n   * visit for that layer with layerLength. As we traverse the graph, everytime we visit an unvisited polygon, we use \n   * the findPolygonNeighbors to populate the queue with polygons we have not yet visited to be included in the \n   * following layer. We are also creating the array of polygon names for that layer to be added to the main array. When\n   * our visitQueue is empty, we have been to all of the connected polygons. \n   * \n   * O(n): O(p + e) where p represents the number of polygons in the graph and e represents the connecting edges \n   * \n   * @param originPolygon the polygon to look for neighbor layers from\n   * @returns array of polygon names for each layer\n   */\n  findPolygonNeighborLayers(originPolygon: Polygon): string[][]{\n    let neighborLayer: string[][] = [[]];\n    neighborLayer[0].push(originPolygon.name);\n    let visitedPolygons: Set<Polygon> = new Set();\n    let visitQueue: Polygon[] = [originPolygon];\n    let layerCount = 1\n    \n    while(visitQueue.length > 0){\n      //prepare layer\n      let layerLength = visitQueue.length;\n      neighborLayer.push([]);\n\n      for(let i=0; i<layerLength; i++){\n        //get polygon and remove from queue\n        let currentPolygon = visitQueue[0];\n        visitQueue.splice(0,1);\n        \n        //mark as visited\n        visitedPolygons.add(currentPolygon);\n\n        //get neighbors \n        const neighbors: Polygon[] = this.findPolygonNeighbors(currentPolygon);\n\n        //for each neighbor, if it has not been visited yet\n        for (let neighborPolygon of neighbors){\n          if(!visitedPolygons.has(neighborPolygon)){\n            //add neighbor to its respective layer array\n            neighborLayer[layerCount].push(neighborPolygon.name);\n            \n            //mark as visited\n            visitedPolygons.add(neighborPolygon);\n            \n            //add to visitation queue\n            visitQueue.push(neighborPolygon);\n          }\n        }      \n      }\n      layerCount += 1;\n    }\n    //remove last empty array\n    neighborLayer.splice(neighborLayer.length-1,1);\n    return neighborLayer;\n  }\n} //closes DCEL class\n\n\n\n","import {Polygon} from \"./DCEL\"\n\n/**\n * Type to define a 2d point. \n */\nexport type Point = {\n  x: number;\n  y: number;\n};\n\n\n/** \n * Determine the path orientation/direction of three ordered points. \n * \n * Given three ordered points, this will calculate a value to determine if the direction of travel through them.\n * Returns 0 for Clockwise, 1 for Counter-Clockwise, and 2 for Co-linear.\n * \n * @param p1 - first point  \n * @param p2 - second point\n * @param p3 - third point\n * @returns number representing direction, 0 for CW; 1 for CCW, 2 for colienar\n */\nfunction pathOrientation(p1:Point, p2:Point, p3:Point): number{\n  let val = (p1.x-p2.x)*(p3.y-p2.y) - (p1.y-p2.y)*(p3.x-p2.x);\n\n  //is clockwise\n  if(val > 0){\n    return 0;\n  }\n  //is counter-clockwise or on an edge\n  else if(val < 0) {\n    return 1;\n  }\n  //is co-linear\n  else {return 2;}\n}\n\n\n/**\n * Given 3 colinear points, checks if point R is on segment P-Q\n * \n * Checks that the x and y coordinate of the point in question (R) lies within the min and max of the segement (P-Q) end\n * points' x and y. This function assumes the given points are colinear. Can check this via the pathOrientation function.\n * \n * @param P start point of segment \n * @param Q end point of segement \n * @param R point check\n * @returns boolean, true for on segment, false for not on segment\n */\nfunction onColinearSegment(P: Point, Q:Point, R: Point): boolean{\n  const inMaxX = (R.x <= Math.max(P.x, Q.x));\n  const inMinX = (R.x >= Math.min(P.x, Q.x));\n  const inMaxY = (R.y <= Math.max(P.y, Q.y));\n  const inMinY = (R.y >= Math.min(P.y, Q.y));\n  if (inMaxX && inMinX && inMaxY && inMinY){\n    return true;\n  }\n  return false;\n}\n\n\n/**\n * Calculates the point's winding number with respect to the given polygon\n * \n * This function looks at all the edges that cross a vertical axis though the point. It calculates the path orientation \n * from the segment start point --> point --> segment end point. The path orientation in conjunction with the edge \n * direction determines if you add or subtract from the winding number. The function returns the winding number. If a \n * point is on a polygon edge, it is considered to be outside of it and returns wind = 0. \n * \n * wind = 0: point is outside polygon, wind != 0 point is inside polygon\n * \n * This method makes it simple to handle nuances of complex polygons and points that line up with edges. \n * \n * O(n) where n is number of edges in polygon\n * \n * @param polygon polygon as a Polygon of the DCEL structure\n * @param point point as Point type object\n * @returns number representing the winding number\n */\nfunction windingNumber(polygon: Polygon, point:Point): number{\n  let wind = 0;\n  for(let edge of polygon.edges){ \n    const P: Point = {x: edge.startVertex.x, y: edge.startVertex.y}\n    const Q: Point = {x: edge.endVertex.x, y: edge.endVertex.y}\n\n    const delta = pathOrientation(P, point, Q);\n\n    //if crosses ray clockwise (delta = 0) and positive direction edge\n    if((P.x <= point.x) && (point.x< Q.x && delta === 0)){\n      wind += 1;\n    }\n    //if crosses ray counter-clockwise (delta = 1) and negative direction edge\n    if((Q.x <= point.x) && (point.x < P.x) && delta === 1){\n      wind -= 1;\n    } \n    //if colinear and point is on edge, point is returned as outside polygon. else, continue counting winding number\n    if(delta === 2){\n      const onSegment = onColinearSegment(P, Q, point);\n      if(onSegment){\n        wind = 0;\n        break;\n      }\n    }\n  }\n  return wind;\n}\n\n\n/** \n * Returns boolean representing if point is inside polygon\n * \n * @param polygon - polygon\n * @param point - point\n * @returns boolean representing inside or outside of polygon, false for outside polygon; true for inside polygon\n * \n */\nexport function pointInPolygon(polygon: Polygon, point: Point): boolean{\n  const value = windingNumber(polygon, point);\n  return value !== 0\n}\n\n","import React from 'react';\nimport './App.css';\nimport {GraphSVG} from \"./graphSVG\"\nimport {algorithm1, algorithm3,algorithm2, algorithm4}  from \"./Algorithms\"\nimport { stringBuilder } from './Utils';\nimport testData from \"./TestData.json\"\n\n\n\n/**\n * Runs the algorithms and creates simple UI using React components to output html\n * @returns html for UI\n */\nfunction App() {\n  //dropdown state\n  let [testCase, setTestCase] = React.useState(\"0\");\n  let testCaseIndex: number = +testCase;\n  \n  //get test case data\n  const dataGraph = {vertices: testData[testCaseIndex].vertices, edges: testData[testCaseIndex].edges}\n  //let title = testData[testCaseIndex].title;\n  const description = testData[testCaseIndex].description;\n  const neighborOrigin = testData[testCaseIndex].neighborOrigin;\n  const pointInPolygon: [number,number] = [testData[testCaseIndex].pointInPolygon[0],testData[testCaseIndex].pointInPolygon[1]];\n\n  //run algorithms\n  const output1 = algorithm1(dataGraph);\n  const output2 = algorithm2(output1, neighborOrigin);\n  const output3 = algorithm3(output1, pointInPolygon);\n  const output4 = algorithm4(output1, neighborOrigin);\n\n  //create display text\n  let descriptionText = stringBuilder(\"Description: \", description);\n  const text1 = \"algorithm 1: found \" + output1.polygons.length.toString() + \" polygons\";\n  const text2 = \"algorithm 2: Polygon \" + output2[0] + \" neighbors- \" + output2[1];\n  const text3 = \"algorithm 3: Point [\" + pointInPolygon[0] + \",\"+ pointInPolygon[1] + \"] is in \" + output3;\n  const text4 = \"algorithm 4: \" + output4;\n\n  function dropdownOptions (){\n    const options = [];\n    for(let i =0; i<testData.length; i++){\n      const name = testData[i].title;\n      const uniqueKey = \"option\" + i.toString();\n      options.push(\n        <option value={i} key={uniqueKey}>{name}</option>\n      )\n    }\n    return options;\n  }\n  \n  //handles the dropdown list updates\n  function handleOnChange(e: string){\n    setTestCase(e);\n    console.log(\"Updated graph\")\n  }\n\n\n  return (\n    <div className=\"App\">\n      <GraphSVG data={output1} />\n      <div className=\"Input-Output\"> \n        <div className=\"Input-data\">\n          <select id = \"dropdown\" onChange={(e) =>handleOnChange(e.target.value)} value={testCase}>\n            {dropdownOptions()}\n          </select>\n        </div>\n        <div className=\"Output-data\">\n          <div className=\"TestCaseOutputText\">{descriptionText}</div>\n          <div className=\"TestCaseOutputText\">{text1}</div>\n          <div className=\"TestCaseOutputText\">{text2}</div>\n          <div className=\"TestCaseOutputText\">{text3}</div>\n          <div className=\"TestCaseOutputText\">{text4}</div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import {jsonGraph} from \"./Utils\";\nimport {DCEL, Polygon} from \"./DCEL\"\nimport {pointInPolygon, Point} from \"./PointInPolygon\"\n\n\n/**\n * Returns DCEL data structure in json format\n * \n * Generates a DCEL data structure from vertices and edges in the provided format. After some research, I found that \n * the DCEL data structure makes it simple to traverse edges to find the inside polygon cycles. \n * \n * Additionally, the vertex, directed edge, and polygon class properties simplify the process of traversing the \n * graph for future algorithms. It is self referential in that vertices know what edges originate from them and edges \n * know their start/end vertices. Edges know their twin- the directed edge with a reverse direction. Edges know what \n * polygon they are a part of and polygons know their edges. Each of these elements holding on to this information makes \n * it really easy to travel across the graph. \n * \n * The bulk of the work for this algorithm is done with the fromVerticesEdges function. It formats the given vertex and\n * edge data in the DCEL structure and then does a DFS of the edges to find the polygon cycles. The time complexity is \n * O(n) where n is the number of edges. \n * \n * As a last step, this algorithm outputs the DCEL in a json format where edges refer to vertices by their index in the \n * vertex array, and polygons refer to edges by their index in the edge array. This format replaces the self referential \n * nature of the DCEL class, but also makes it easy to recreate the DCEL data structure as a DCEL class object. \n * \n * @param inputData \n * @returns jsonGraph\n */\nexport function algorithm1(inputData:{vertices: number[][];edges: number[][];}): jsonGraph{\n    console.log(\"algorithm 1\");\n    \n    //creates DCEL data structure with the DCEL class\n    let myDCEL = new DCEL();\n    let input = inputData;\n    myDCEL.fromVerticesEdges(input.vertices, input.edges)\n    // console.log(myDCEL);\n    \n    //formats DCEL data structure in a json format\n    const jsonGraph = myDCEL.toJSON();\n    console.log(jsonGraph);\n    \n    return jsonGraph;\n}\n\n/**\n * Returns the index of the origin polygon from the DCEL and the names of the polygon's neighbors \n * \n * This algorithm initially recreates the DCEL data structure from the DCEL json data. It checks that the given polygon\n * index exists in the graph. If not, it will default to the first polygon in the graph array. Then the bulk of the work\n * is done by the findPolygonNeighbors function. The DCEL data structure has existing references that make it easy to \n * traverse the graph to find neighboring polygons. For more detail on the path the function takes, see details in the \n * findPolygonNeighbors function.\n * \n * O(n) where n represents the number of edges in the polygon.  \n * \n * @param inFromA1 the jsonGraph of the DCEL generated in algorithm1\n * @param originPolygonIndex index of origin polygon from the json graph\n * @returns index of origin polygon and string of polygon neighbor names\n */\nexport function algorithm2(inFromA1: jsonGraph, originPolygonIndex: number){\n    console.log(\"algorithm 2\");\n    \n    let myDCEL = new DCEL();\n    myDCEL.fromVerticesEdgesPolygons(inFromA1.vertices, inFromA1.edges, inFromA1.polygons);\n    //console.log(myDCEL);\n\n    //check index of polygon lands within polygon list length\n    let index = originPolygonIndex;\n    if(index >= myDCEL.polygons.length){\n        index = 0\n    }\n\n    //finds the polygon neighbors\n    const originPolygon = myDCEL.polygons[index];\n    const polygonNeighbors = myDCEL.findPolygonNeighbors(originPolygon);\n    \n    //returns neighbor info as string to display\n    //html polygon id is the same as the DCEL polygon name\n    const polygonNeighborNames = polygonNeighbors.map(a => a.name);\n    console.log(\"Polygon \" + index + \" neighbors are \" + polygonNeighborNames.join(\", \"));\n    return [index, polygonNeighborNames];\n}\n\n/**\n * Returns a string of the containing polygon name, if any exists in the given graph\n * \n * This algorithm initially recreates the DCEL data structure from the DCEL json data. Then it loops through each polygon\n * to determine if the given point is inside of it. If it is inside, the name of that polygon will be returned. If no \n * polygon is found that will be noted in the return string. \n * \n * Each time we check if the point is in a polygon, we are using the pointInPolygon function. After some research, I \n * decided to use the optimized version of the winding number algorithm to determine if the point was inside or outside. \n * The original winding number algorithm was the sum of the angle from the point to each edge. If it was a multiple of \n * 2pi the point was inside. The geometric intution behind this was simple, but reqired the use of many trigonometric \n * functions. The ray casting method, on the other hand, was faster, but required more nuances to handle complex polygons.\n * Therefore, the known edited version of the winding number algorithm seemed to be the best option forward . A \n * description of this algorithm can be found with the windingNumber function in PointInPolygon.tsx\n * \n * The time complexity of this algorithm is O(p) where p is the number of polygons in the given graph, but for each \n * polygon, O(e) where n represents the number of edges for that polygon. Therefore, the worst case where the point is \n * not in any polygon is O(n), where n is the number of edges in the graph because we would look at every edge for every\n * polygon.  \n * \n * @param inFromA1 the jsonGraph of the DCEL generated in algorithm1\n * @param pointCoordinates the x,y coordinate of the point in question\n * @returns string formatted with the name of the containing polygon, if any\n */\nexport function algorithm3(inFromA1: jsonGraph, pointCoordinates:[number, number]){\n    console.log(\"algorithm 3\");\n    \n    //format graph data as DCEL\n    const myDCEL = new DCEL();\n    myDCEL.fromVerticesEdgesPolygons(inFromA1.vertices, inFromA1.edges, inFromA1.polygons);\n    \n    //define point for pointInPolygon inputs\n    const point: Point = {x:pointCoordinates[0],y:pointCoordinates[1]};\n  \n    //for each polygon of the graph, check if polygon contains point. \n    //point on an edge of polygon is outside \n    let containerPolygon: Polygon | undefined = undefined;\n    for(let polygon of myDCEL.polygons){\n      const pIP = pointInPolygon(polygon, point);\n      if(pIP){\n        containerPolygon = polygon;\n        break;\n      }\n    }\n\n    //return container polygon name \n    if(containerPolygon !== undefined){\n      //return text to display\n      console.log(\"Point [\" + point.x + \",\"+ point.y + \"] is in \" + containerPolygon.name);\n      return(containerPolygon.name);\n    }\n    else{\n      //return text to display\n      console.log(\"Point [\" + point.x + \",\"+ point.y + \"] is in no polygon\")\n      return(\"no polygons\")\n    }\n}\n\n/**\n * Returns neighbor layers as a string representing an array with an array of polygon names for each layer\n * \n * This algorithm initially recreates the DCEL data structure from the DCEL json data. It checks that the given polygon\n * index exists in the graph. If not, it will default to the first polygon in the graph array. Then the bulk of the work\n * is done by the findPolygonNeighborLayers function. This function uses a BFS to traverse the graph and find neighbor\n * layers. It calls on the findPolygonNeighbors function from algorithm 2 to help fill the queue to visit. For more \n * detail, see the findPolygonNeighborLayers function.\n * \n * O(n): O(p + e) where p represents the number of polygons in the graph and e represents the connecting edges\n * \n * @param inFromA1 the jsonGraph of the DCEL generated in algorithm1\n * @param originPolygonIndex index of origin polygon from the json graph\n * @returns returns an array with an array for each layer of polygons by name \n */\nexport function algorithm4(inFromA1: jsonGraph, originPolygonIndex: number){\n    console.log(\"algorithm 4\");\n    \n    // format output from algorithm1 back to DCEL\n    const myDCEL = new DCEL();\n    myDCEL.fromVerticesEdgesPolygons(inFromA1.vertices, inFromA1.edges, inFromA1.polygons);\n    // console.log(myDCEL);\n\n    // check index of polygon lands within polygon list length\n    let index = originPolygonIndex;\n    if(index >= myDCEL.polygons.length){\n        index = 0\n    }\n    \n    // get neighbor layers as an array of polygon ids\n    // html polygon id is the same as the DCEL polygon name\n    const originPolygon = myDCEL.polygons[index];\n    const polygonNeighborLayers = myDCEL.findPolygonNeighborLayers(originPolygon);\n\n    // returns neighbor layer info as string to display\n    console.log(polygonNeighborLayers);\n    return JSON.stringify(polygonNeighborLayers);\n}","/**\n * Json format for a DCEL graph\n */\nexport interface jsonGraph {\n    vertices: number[][];\n    edges: number[][];\n    polygons: number[][];\n}\n\n/**\n * Concatenates the two given strings\n * \n * @param s1 string1\n * @param s2 string2\n * @returns string1 + string2\n */\nexport function stringBuilder(s1: string, s2: string): string{\n  const s: string = s1.concat(s2);\n  return s;\n} \n\n\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}